<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maths Facts Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .card {
            background-color: white;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease-in-out;
            width: 95%;
            max-width: 700px;
        }
        .btn {
            display: inline-block;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            text-align: center;
        }
        .btn:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #4338ca;
        }
        .btn-secondary {
            background-color: #10b981;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #059669;
        }
        .input-field {
            border: 2px solid #d1d5db;
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            width: 100%;
            font-size: 1.5rem;
            text-align: center;
            font-weight: 700;
            transition: border-color 0.2s ease-in-out;
        }
        .input-field:focus {
            outline: none;
            border-color: #4f46e5;
        }
        .input-field:disabled {
            background-color: #f3f4f6;
        }
        .question-text {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: 700;
            color: #1f2937;
            letter-spacing: 2px;
        }
        .feedback {
            height: 2rem;
            font-weight: 600;
            transition: all 0.3s;
        }
        .feedback-correct { color: #10b981; }
        .feedback-incorrect { color: #ef4444; }
        
        .level-section-title {
            text-align: left;
            font-size: 1.5rem;
            font-weight: 800;
            color: #374151;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e5e7eb;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 1rem;
        }
        .level-btn {
            border: 2px solid #e5e7eb;
            border-radius: 1rem;
            padding: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100px;
        }
        .level-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .level-title {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-align: center;
            line-height: 1.2;
        }
        .best-time {
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: 0.5rem;
        }
        
        /* Rating-based colors */
        .rating-none { background-color: #f3f4f6; color: #374151; }
        .rating-apprentice { background-color: #dcfce7; color: #166534; border-color: #86efac; }
        .rating-pro { background-color: #a7f3d0; color: #047857; border-color: #6ee7b7; }
        .rating-expert { background-color: #6ee7b7; color: #065f46; border-color: #34d399; }
        .rating-mastery { background: linear-gradient(145deg, #fde047, #facc15); color: #a16207; border-color: #f59e0b; }
        .rating-true-mastery { background: linear-gradient(145deg, #fce7f3, #f9a8d4); color: #9d174d; border-color: #f472b6; }
        
        #confetti-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <canvas id="confetti-canvas"></canvas>

    <div class="container mx-auto text-center">

        <div id="settings-screen" class="card mx-auto">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-2">Maths Facts Challenge</h1>
            <p class="text-gray-600 mb-8">Select a level. Get 20 in a row to set your best time!</p>
            <div id="level-selection-container"></div>
        </div>

        <div id="game-screen" class="card mx-auto hidden">
            <div class="flex justify-between items-center mb-6 text-lg">
                <div class="font-semibold text-gray-700">Streak: <span id="streak-counter" class="font-bold text-indigo-600 text-xl">0</span></div>
                <div class="font-semibold text-gray-700">Time: <span id="timer" class="font-bold text-indigo-600 text-xl">00:00</span></div>
            </div>
            <div id="question-container" class="my-8 min-h-[60px] flex items-center justify-center">
                <p id="question-text" class="question-text"></p>
            </div>
            <div class="mb-4">
                <input type="number" id="answer-input" class="input-field" placeholder="?">
            </div>
            <div id="feedback-message" class="feedback mb-4 text-lg"></div>
            <button id="check-btn" class="btn btn-primary w-full max-w-xs mx-auto text-lg">Check Answer</button>
			<br>
            <button id="quit-btn" class="mt-4 text-gray-500 hover:text-gray-700 font-semibold">Back to Levels</button>
        </div>

        <div id="success-screen" class="card mx-auto hidden">
            <h2 class="text-3xl md:text-4xl font-bold text-green-500 mb-4">üéâ Challenge Complete! üéâ</h2>
            <p class="text-gray-700 text-xl mb-2">You got 20 in a row for <span id="completed-level" class="font-bold"></span>!</p>
            <p class="text-gray-700 text-xl mb-4">Your time: <span id="final-time" class="font-bold text-indigo-600"></span></p>
            <div id="rating-info" class="bg-indigo-100 text-indigo-800 rounded-xl p-4 mb-6">
                <p class="text-lg font-semibold">Rating: <span id="final-rating" class="font-bold"></span></p>
                <p id="best-time-message" class="mt-1 font-medium"></p>
                <p id="rating-explanation" class="text-sm mt-2 text-indigo-700"></p>
            </div>
            <button id="play-again-btn" class="btn btn-secondary w-full max-w-xs mx-auto text-lg">Back to Levels</button>
        </div>

    </div>

    <script>
        // Math Facts Challenge Game
        const MathFactsGame = (() => {
            
            // ==================== Configuration ====================
            const CONFIG = {
                // Levels are now grouped by category
                LEVEL_GROUPS: {
                    "Positive Bonds": [
                        { key: 'bonds10', name: 'Bonds to 10', value: 10 },
                        { key: 'bonds20', name: 'Bonds to 20', value: 20 },
                        { key: 'mixed10-20', name: 'Mixed Bonds 10-20', customMixedRange: [10, 20] },
                        { key: 'bonds30', name: 'Bonds to 30', value: 30 },
                        { key: 'bonds50', name: 'Bonds to 50', value: 50 },
                        { key: 'bonds60', name: 'Bonds to 60', value: 60 },
                        { key: 'bonds90', name: 'Bonds to 90', value: 90 },
                        { key: 'bonds100', name: 'Bonds to 100', value: 100 },
                        { key: 'positive-mixed', name: 'Mixed Positive Practice' },
                    ],
                    "Negative Bonds": [
                        { key: 'bonds-10', name: 'Bonds to -10', value: -10 },
                        { key: 'bonds-20', name: 'Bonds to -20', value: -20 },
                        { key: 'bonds-50', name: 'Bonds to -50', value: -50 },
                        { key: 'bonds-100', name: 'Bonds to -100', value: -100 },
                        { key: 'negative-mixed', name: 'Mixed Negative Practice' },
                    ],
                    "Multiplication & Division": [
                        { key: 'group245', name: '√ó√∑ 2 4 5 10' },
                        { key: 'group369', name: '√ó√∑ 3 6 9' },
                        { key: 'multall', name: '√ó√∑ 2-12 Mixed' },
                        { key: 'mixed-negative-mult', name: '√ó√∑ Mixed Negatives' },
                        { key: 'double100', name: 'Doubling' },
                        { key: 'squares', name: 'Perfect Squares' },
                        { key: 'mixedall', name: 'Mixed Multiplication' },
                    ]
                },
                REQUIRED_STREAK: 20,
                FEEDBACK_DELAY_CORRECT: 300,
                FEEDBACK_DELAY_INCORRECT: 1000,
                POSITIVE_FEEDBACK: ["Awesome!", "Great Job!", "You got it!", "Fantastic!", "Brilliant!", "Keep it up!"],
                RATING_THRESHOLDS: [
                    { maxAvg: 1.5, name: "üíñ True Mastery üíñ", key: "true-mastery" },
                    { maxAvg: 2, name: "‚ö°Ô∏è Mastery ‚ö°Ô∏è", key: "mastery" },
                    { maxAvg: 3, name: "Expert", key: "expert" },
                    { maxAvg: 4, name: "Pro", key: "pro" },
                    { maxAvg: Infinity, name: "Apprentice", key: "apprentice" }
                ],
                STORAGE_PREFIX: 'mf_bestTime_v1_', // Merged app prefix
                CONFETTI: {
                    CORRECT: 40,
                    SUCCESS: 150
                }
            };

            // ==================== Game State Manager ====================
            class GameState {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.currentLevel = null;
                    this.currentAnswer = 0;
                    this.correctStreak = 0;
                }

                setLevel(level) {
                    this.reset();
                    this.currentLevel = level;
                }

                incrementStreak() {
                    this.correctStreak++;
                    return this.correctStreak;
                }

                resetStreak() {
                    this.correctStreak = 0;
                }

                isComplete() {
                    return this.correctStreak >= CONFIG.REQUIRED_STREAK;
                }
            }

            // ==================== Question Generator ====================
            class QuestionGenerator {
                // --- Multiplication/Division Helpers ---
                generateSingleTableFacts(table) {
                    const factor = Math.floor(Math.random() * 12) + 1;
                    const product = table * factor;
                    const type = Math.floor(Math.random() * 4);
                    
                    switch(type) {
                        case 0: return { format: `${table} √ó <span class="text-indigo-600">___</span> = ${product}`, answer: factor };
                        case 1: return { format: `<span class="text-indigo-600">___</span> √ó ${factor} = ${product}`, answer: table };
                        case 2: return { format: `${product} √∑ ${table} = <span class="text-indigo-600">___</span>`, answer: factor };
                        default: return { format: `${product} √∑ <span class="text-indigo-600">___</span> = ${factor}`, answer: table };
                    }
                }

                generateNegativeTableFacts(table) {
                    let factor = Math.floor(Math.random() * 12) + 1;
                    
                    // Randomly make one of the numbers negative
                    if (Math.random() < 0.5) {
                        table = -table;
                    } else {
                        factor = -factor;
                    }

                    const product = table * factor;
                    const type = Math.floor(Math.random() * 4);
                    
                    switch(type) {
                        case 0: return { format: `${table} √ó <span class="text-indigo-600">___</span> = ${product}`, answer: factor };
                        case 1: return { format: `<span class="text-indigo-600">___</span> √ó ${factor} = ${product}`, answer: table };
                        case 2: return { format: `${product} √∑ ${table} = <span class="text-indigo-600">___</span>`, answer: factor };
                        default: return { format: `${product} √∑ <span class="text-indigo-600">___</span> = ${factor}`, answer: table };
                    }
                }

                generateGroupFacts(tables) {
                    const table = tables[Math.floor(Math.random() * tables.length)];
                    return this.generateSingleTableFacts(table);
                }
                
                generateDoubling(maxNumber) {
                    const number = Math.floor(Math.random() * maxNumber) + 1;
                    const double = number * 2;
                    return { format: `${number} √ó 2 = <span class="text-indigo-600">___</span>`, answer: double };
                }

                generatePerfectSquares() {
                    const base = Math.floor(Math.random() * 12) + 1; // Keep it to 12x12 for common facts
                    const square = base * base;
                    const type = Math.floor(Math.random() * 2);
                    
                    if (type === 0) {
                        return { format: `${base}<sup>2</sup> = <span class="text-indigo-600">___</span>`, answer: square };
                    } else {
                        return { format: `<span style="font-size: 1.5em;">‚àö</span><span style="text-decoration: overline;">${square}</span> = <span class="text-indigo-600">___</span>`, answer: base };
                    }
                }
                
                generateMixedMultiplication() {
                     const questionType = Math.floor(Math.random() * 3);
                     if (questionType === 0) return this.generateGroupFacts([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
                     if (questionType === 1) return this.generateDoubling(100);
                     return this.generatePerfectSquares();
                }

                // --- Main Generate Method ---
                generate(level) {
                    // Part 1: Check for Multiplication/Division level types
                    switch(level.key) {
                        case 'mixedall': return this.generateMixedMultiplication();
                        case 'multall': return this.generateGroupFacts([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
                        case 'group245': return this.generateGroupFacts([2, 4, 5, 10]);
                        case 'group369': return this.generateGroupFacts([3, 6, 9]);
                        case 'double100': return this.generateDoubling(100);
                        case 'squares': return this.generatePerfectSquares();
                        case 'mixed-negative-mult':
                            const tables = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
                            const table = tables[Math.floor(Math.random() * tables.length)];
                            return this.generateNegativeTableFacts(table);
                    }

                    // Part 2: Handle Number Bonds if no multiplication key matched
                    let targetNumber;

                    if (level.customMixedRange) {
                        const [min, max] = level.customMixedRange;
                        targetNumber = Math.floor(Math.random() * (max - min + 1)) + min;
                    } 
                    else if (level.key.includes('mixed')) {
                        let sourceLevels;
                        if (level.key.includes('positive')) {
                            sourceLevels = CONFIG.LEVEL_GROUPS['Positive Bonds'].filter(l => l.value !== undefined);
                        } else {
                            sourceLevels = CONFIG.LEVEL_GROUPS['Negative Bonds'].filter(l => l.value !== undefined);
                        }
                        const randomLevel = sourceLevels[Math.floor(Math.random() * sourceLevels.length)];
                        targetNumber = randomLevel.value;
                    } 
                    else {
                        targetNumber = level.value;
                    }

                    let num1, num2;

                    if (targetNumber >= 0) {
                        num1 = Math.floor(Math.random() * (targetNumber + 1));
                    } else {
                        const range = Math.abs(targetNumber) * 2;
                        const offset = targetNumber;
                        num1 = Math.floor(Math.random() * range) + offset;
                    }
                    
                    num2 = targetNumber - num1;
                    const type = Math.floor(Math.random() * 4);
                    
                    switch(type) {
                        case 0: return { format: `${num1} + <span class="text-indigo-600">___</span> = ${targetNumber}`, answer: num2 };
                        case 1: return { format: `<span class="text-indigo-600">___</span> + ${num2} = ${targetNumber}`, answer: num1 };
                        case 2: return { format: `${targetNumber} - ${num1} = <span class="text-indigo-600">___</span>`, answer: num2 };
                        default: return { format: `${targetNumber} - <span class="text-indigo-600">___</span> = ${num2}`, answer: num1 };
                    }
                }
            }

            // ==================== Storage Manager ====================
            class StorageManager {
                static getBestTime(levelKey) {
                    const time = localStorage.getItem(`${CONFIG.STORAGE_PREFIX}${levelKey}`);
                    return time ? parseInt(time) : null;
                }

                static saveBestTime(levelKey, time) {
                    localStorage.setItem(`${CONFIG.STORAGE_PREFIX}${levelKey}`, time);
                }

                static getRating(seconds) {
                    const avgSecondsPerQuestion = seconds / CONFIG.REQUIRED_STREAK;
                    return CONFIG.RATING_THRESHOLDS.find(r => avgSecondsPerQuestion < r.maxAvg);
                }
            }

            // ==================== Timer Manager ====================
            class Timer {
                constructor(displayElement) {
                    this.displayElement = displayElement;
                    this.interval = null;
                    this.seconds = 0;
                }

                start() {
                    this.stop();
                    this.seconds = 0;
                    this.update();
                    this.interval = setInterval(() => {
                        this.seconds++;
                        this.update();
                    }, 1000);
                }

                stop() {
                    if (this.interval) {
                        clearInterval(this.interval);
                        this.interval = null;
                    }
                }

                reset() {
                    this.stop();
                    this.seconds = 0;
                    this.update();
                }

                update() {
                    const minutes = Math.floor(this.seconds / 60);
                    const secs = this.seconds % 60;
                    this.displayElement.textContent = 
                        `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }

                getSeconds() {
                    return this.seconds;
                }
            }

            // ==================== Confetti Manager ====================
            class ConfettiManager {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');
                    this.particles = [];
                    this.resizeCanvas();
                    window.addEventListener('resize', () => this.resizeCanvas());
                    this.animate();
                }

                resizeCanvas() {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                }

                trigger(count) {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    for (let i = 0; i < count; i++) {
                        this.particles.push({
                            x: centerX,
                            y: centerY,
                            radius: Math.random() * 3 + 2,
                            color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                            velocity: {
                                x: (Math.random() - 0.5) * 15,
                                y: (Math.random() - 0.5) * 15
                            },
                            alpha: 1,
                            friction: 0.98,
                            gravity: 0.1
                        });
                    }
                }

                animate() {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.particles = this.particles.filter(p => {
                        p.velocity.x *= p.friction;
                        p.velocity.y *= p.friction;
                        p.velocity.y += p.gravity;
                        p.x += p.velocity.x;
                        p.y += p.velocity.y;
                        p.alpha -= 0.01;

                        if (p.alpha > 0) {
                            this.ctx.save();
                            this.ctx.globalAlpha = p.alpha;
                            this.ctx.beginPath();
                            this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                            this.ctx.fillStyle = p.color;
                            this.ctx.fill();
                            this.ctx.restore();
                            return true;
                        }
                        return false;
                    });

                    requestAnimationFrame(() => this.animate());
                }
            }

            // ==================== UI Manager ====================
            class UIManager {
                constructor() {
                    this.screens = {
                        settings: document.getElementById('settings-screen'),
                        game: document.getElementById('game-screen'),
                        success: document.getElementById('success-screen')
                    };
                    
                    this.elements = {
                        levelContainer: document.getElementById('level-selection-container'),
                        streakCounter: document.getElementById('streak-counter'),
                        questionText: document.getElementById('question-text'),
                        answerInput: document.getElementById('answer-input'),
                        feedbackMessage: document.getElementById('feedback-message'),
                        checkBtn: document.getElementById('check-btn'),
                        quitBtn: document.getElementById('quit-btn'),
                        playAgainBtn: document.getElementById('play-again-btn'),
                        completedLevel: document.getElementById('completed-level'),
                        finalTime: document.getElementById('final-time'),
                        finalRating: document.getElementById('final-rating'),
                        bestTimeMessage: document.getElementById('best-time-message'),
                        ratingExplanation: document.getElementById('rating-explanation')
                    };
                }

                showScreen(screenName) {
                    Object.values(this.screens).forEach(s => s.classList.add('hidden'));
                    this.screens[screenName].classList.remove('hidden');
                }

                renderLevelGrid(levelGroups, onLevelSelect) {
                    this.elements.levelContainer.innerHTML = '';
                    
                    for (const [groupName, levels] of Object.entries(levelGroups)) {
                        const groupTitle = document.createElement('h2');
                        groupTitle.className = 'level-section-title';
                        groupTitle.textContent = groupName;
                        this.elements.levelContainer.appendChild(groupTitle);

                        const grid = document.createElement('div');
                        grid.className = 'level-grid';

                        levels.forEach(level => {
                            const bestTime = StorageManager.getBestTime(level.key);
                            const rating = bestTime ? StorageManager.getRating(bestTime).key : 'none';
                            const displayText = bestTime ? `üèÜ ${this.formatTime(bestTime)}` : 'No time yet';
                            
                            const button = document.createElement('button');
                            button.className = `level-btn rating-${rating}`;
                            button.innerHTML = `
                                <div class="level-title">${level.name}</div>
                                <div class="best-time">${displayText}</div>
                            `;
                            button.addEventListener('click', () => onLevelSelect(level));
                            grid.appendChild(button);
                        });
                        this.elements.levelContainer.appendChild(grid);
                    }
                }

                updateStreak(streak) {
                    this.elements.streakCounter.textContent = streak;
                }

                showQuestion(questionHTML) {
                    this.elements.questionText.innerHTML = questionHTML;
                    this.elements.answerInput.value = '';
                    this.elements.answerInput.disabled = false;
                    this.elements.checkBtn.disabled = false;
                    this.elements.answerInput.focus();
                    this.clearFeedback();
                }

                showFeedback(message, isCorrect) {
                    this.elements.feedbackMessage.textContent = message;
                    this.elements.feedbackMessage.className = 
                        `feedback mb-4 text-lg ${isCorrect ? 'feedback-correct' : 'feedback-incorrect'}`;
                }

                clearFeedback() {
                    this.elements.feedbackMessage.textContent = '';
                    this.elements.feedbackMessage.className = 'feedback mb-4 text-lg';
                }

                disableInput() {
                    this.elements.answerInput.disabled = true;
                    this.elements.checkBtn.disabled = true;
                }

                getAnswer() {
                    const value = this.elements.answerInput.value;
                    if (value === '' || value === '-') return NaN;
                    return parseInt(value);
                }

                showSuccess(levelName, time, rating, isNewBest, previousBest) {
                    document.getElementById('completed-level').textContent = levelName;
                    document.getElementById('final-time').textContent = this.formatTime(time);
                    this.elements.finalRating.textContent = rating.name;
                    this.elements.ratingExplanation.textContent = 
                        'Ratings are based on average time per question. Mastery is under 2 seconds!';
                    
                    if (isNewBest) {
                        this.elements.bestTimeMessage.textContent = "üèÜ New best time!";
                    } else {
                        this.elements.bestTimeMessage.textContent = 
                            `Your best is ${this.formatTime(previousBest)}. Keep trying!`;
                    }
                    
                    this.showScreen('success');
                }

                formatTime(seconds) {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
            }

            // ==================== Main Game Controller ====================
            class GameController {
                constructor() {
                    this.state = new GameState();
                    this.ui = new UIManager();
                    this.questionGen = new QuestionGenerator();
                    this.timer = new Timer(document.getElementById('timer'));
                    this.confetti = new ConfettiManager(document.getElementById('confetti-canvas'));
                    
                    this.setupEventListeners();
                    this.init();
                }

                init() {
                    this.ui.renderLevelGrid(CONFIG.LEVEL_GROUPS, (level) => this.startGame(level));
                    this.ui.showScreen('settings');
                }

                setupEventListeners() {
                    this.ui.elements.checkBtn.addEventListener('click', () => this.checkAnswer());
                    this.ui.elements.answerInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') this.checkAnswer();
                    });
                    this.ui.elements.quitBtn.addEventListener('click', () => this.quitGame());
                    this.ui.elements.playAgainBtn.addEventListener('click', () => this.quitGame());
                }

                startGame(level) {
                    this.state.setLevel(level);
                    this.ui.updateStreak(0);
                    this.ui.showScreen('game');
                    this.timer.start();
                    this.generateQuestion();
                }

                generateQuestion() {
                    const question = this.questionGen.generate(this.state.currentLevel);
                    this.state.currentAnswer = question.answer;
                    this.ui.showQuestion(question.format);
                }

                checkAnswer() {
                    if (this.ui.elements.checkBtn.disabled) return;
                    
                    const userAnswer = this.ui.getAnswer();
                    if (isNaN(userAnswer)) return;
                    
                    this.ui.disableInput();
                    
                    if (userAnswer === this.state.currentAnswer) {
                        this.handleCorrectAnswer();
                    } else {
                        this.handleIncorrectAnswer();
                    }
                }

                handleCorrectAnswer() {
                    const streak = this.state.incrementStreak();
                    this.ui.updateStreak(streak);
                    
                    const feedback = CONFIG.POSITIVE_FEEDBACK[
                        Math.floor(Math.random() * CONFIG.POSITIVE_FEEDBACK.length)
                    ];
                    this.ui.showFeedback(feedback, true);
                    this.confetti.trigger(CONFIG.CONFETTI.CORRECT);
                    
                    setTimeout(() => {
                        if (this.state.isComplete()) {
                            this.showSuccess();
                        } else {
                            this.generateQuestion();
                        }
                    }, CONFIG.FEEDBACK_DELAY_CORRECT);
                }

                handleIncorrectAnswer() {
                    this.state.resetStreak();
                    this.ui.updateStreak(0);
                    this.timer.reset();
                    this.timer.start();
                    
                    this.ui.showFeedback(
                        `Not quite. The answer was ${this.state.currentAnswer}.`, 
                        false
                    );
                    
                    setTimeout(() => {
                        this.generateQuestion();
                    }, CONFIG.FEEDBACK_DELAY_INCORRECT);
                }

                showSuccess() {
                    this.timer.stop();
                    const time = this.timer.getSeconds();
                    const previousBest = StorageManager.getBestTime(this.state.currentLevel.key);
                    const isNewBest = !previousBest || time < previousBest;
                    
                    if (isNewBest) {
                        StorageManager.saveBestTime(this.state.currentLevel.key, time);
                        this.confetti.trigger(CONFIG.CONFETTI.SUCCESS);
                    }
                    
                    const rating = StorageManager.getRating(time);
                    this.ui.showSuccess(
                        this.state.currentLevel.name, 
                        time, 
                        rating, 
                        isNewBest, 
                        previousBest
                    );
                }

                quitGame() {
                    this.timer.stop();
                    this.state.reset();
                    this.ui.renderLevelGrid(CONFIG.LEVEL_GROUPS, (level) => this.startGame(level));
                    this.ui.showScreen('settings');
                }
            }

            // ==================== Initialize Game ====================
            return {
                init: () => new GameController()
            };
        })();

        // Start the game when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => MathFactsGame.init());
        } else {
            MathFactsGame.init();
        }
    </script>
</body>
</html>
